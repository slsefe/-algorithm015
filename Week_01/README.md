# 第一周学习笔记

## 1. 数组、链表、跳表

### 1.1 数组array

1. 定义：数组是一种线性表数据结构.它用一组连续的内存空间, 来存储一组具有相同类型的数据.
2. 操作
    - 查找: 在数组中查找元素的时间复杂度为`O(n)`, 在有序数组中使用二分查找的时间复杂度为`O(logn)`.
    - 随机访问:
      - 连续的内存空间和相同类型的数据使得数组具有**随机访问**的特性. 以长度为`n`的`int`类型数组为例, 假设首地址为`base_address`, 则第i个元素的内存地址为`base_address + i * data_type_size`, 其中`data_type_size`为数组类型的字节大小.
      - 数组支持随机访问, 根据下标随机访问的时间复杂度为`O(1)`.
    - 插入:
      - 有序数组的插入操作根据插入位置的不同最好时间复杂度为`O(1)`, 最坏时间复杂度为`O(n)`, 平均时间复杂度为`O(n)`.
      - 无序数组的插入操作可以将要插入位置的元素搬移到数组元素的末尾, 同时插入新的元素, 避免了大量的数据搬移, 时间复杂度为`O(1)`, 快排中使用了这种技巧.
    - 删除:
      - 为了保持数组元素的连续性, 删除操作需要进行数据搬移, 最好时间复杂度为`O(1)`, 最坏时间复杂度为`O(n)`, 平均情况时间复杂度为`O(n)`.
      - 有些特殊情境下, 为了避免进行多次数据搬移, 可以先记录下要删除的数据, 当数组中没有更多存储空间时, 再触发一次真正的删除操作.
3. 实现
    - 针对数组类型, `Java`提供了`ArrayList`, `C++`提供了`vector`. 以`Java`语言为例, `ArrayList`最大的优势是可以将很多数组操作的细节封装起来, 并且支持动态扩容. 如果事先能够确定存储的数据大小, 最好在创建`ArrayList`的时候指定数据大小.
    - 在Python中, 列表list和元组tuple都是一个可以存储任意数据类型的有序集合. 列表是动态的, 长度可变, 可以随意增加/删除/改变元素, 列表的存储空间略大于元组, 性能略逊于元组; 元组是静态的, 长度大小固定, 无法增加/删除/改变, 元组相对于列表更加轻量级, 性能稍优. 两者可以通过`list()`和`tuple()`方法相互转换, 常用的内置函数有: count(item)统计item出现的次数, index(item)返回item第一次出现的索引, reverse()原地反转, sort()进行排序. 元组适合用来存储不变的数据, 列表适合用来存储需要变化的数据. list和tuple的内部都是通过数组array实现的, list因为长度可变是一个over-allocate的array, 而元组是一个长度不变的array.
4. leetcode相关题目
    - 283移动零（双指针）
    - 11盛最多水的容器（首尾指针）
    - 15三数之和（三指针）
    - 88合并两个有序数组（三指针）
    - 26删除排序数组中的重复项（双指针）
    - 80删除排序数组中的重复项二（双指针）

### 1.2 链表linked list

1. 定义：链表是一种线性表数据结构，它用一组任意的存储单元来存储数据，同时存储当前数据元素的直接后继元素所存放的内存地址。
2. 操作
    - 插入和删除操作时间复杂度为`O(n)`
    - 查找某个结点或元素的时间复杂度为`O(n)`
3. 形态
    - 单链表：数据data和后继指针next
    - 双向链表：在单链表的基础上增加了前驱指针prev，支持O(1)找到前驱结点
    - 循环链表：在单链表的基础上将尾结点指向了头结点，支持O(1)找到尾结点
4. leetcode相关题目
    - 19删除链表倒数第N个结点（快慢指针）
    - 876链表中间节点（快慢指针）
    - 141环形链表（快慢指针）
    - 142环形链表二（快慢指针）
    - 206反转链表（迭代、递归）
    - 24两两交换链表节点（迭代、递归）
    - 25K个一组反转链表
    - 21合并两个有序链表（双指针、递归）
    - 23合并K个有序链表（归并、优先级队列）
    - 83删除排序链表中的重复项（双指针）
    - 82删除排序链表中的重复项二（双指针）

### 1.3 数组和链表的比较

1. 时间复杂度
    - 数组随机访问O(1)，链表随机访问O(n)
    - 数组插入删除O(n)，链表插入删除O(1)
2. 访问效率
    - 数组内存空间连续，可使用CPU缓存预读，访问效率更高
    - 链表在内存中非连续存储，对CPU缓存不友好
3. 空间
    - 数组空间固定，可能出现内存不足或者空间浪费
    - 链表天然支持动态扩容，没有空间浪费情况
4. 应用场景
    - 对于查找操作频繁、插入删除操作很少的需求使用数组实现，对于查询操作很少、插入删除操作频繁的需求使用链表实现
    - 对于空间固定的场景使用数组，对于空间不确定的情况使用链表

### 1.4 跳表skip list

1. 定义：有序链表+多级索引
2. 操作：插入、删除、查找O(logn)
3. 应用
    - Redis中的有序集合zset
    - LevelDB

## 2. 栈、队列、双端队列、优先级队列

### 2.1 栈stack

1. 定义：栈是一种操作受限的线性表，只能在表尾进行插入和删除操作。
2. 操作
    - 在栈顶插入元素，入栈push，O(1)
    - 删除栈顶元素并弹出，出栈pop，O（1）
3. 实现
    - 用数组实现：顺序栈
    - 用链表实现：链式栈
4. 应用场景
    - 函数调用
    - 四则表达式求值
    - 括号匹配
    - 浏览器前进后退功能
5. 存在性思考：栈是一种操作受限的线性表，功能不如数组和链表强大，凡是可以使用栈和队列的场景，都可以使用数组和链表来实现。但是，特定的数据结构是对特定场景的抽象，当某个数据集合只需要在一端插入和删除数据，并且满足先进后出的特性，就应该使用栈这种数据结构。
6. leetcode相关题目
    - 20有效的括号（基本操作）
    - 155最小栈（两个栈实现）
    - 730每日温度（单调栈）
    - 84柱状图中最大的矩形（单调栈）
    - 42接雨水（单调栈）

### 2.2 队列 queue

1. 定义：一种操作受限的线性表，满足先进先出，在表头进行删除操作、表尾进行插入操作
2. 操作
    - 入队enqueue O(1)
    - 出队dequeue O(1)
3. 实现：使用head和tail指针分别指向表头和表尾
    - 用数组实现：顺序队列
    - 用链表实现：链式队列
4.应用场景
    - 循环队列：避免顺序队列出队操作时频繁的数据搬移
5. leetcode相关题目

### 2.3 双端队列deque

1. 定义：在线性表两端都可以进行插入和删除操作
2. 操作
    - 表头出队popleft O(1)
    - 表尾入队push O(1)
    - 表尾出队pop O(1)
    - 表头入队pushleft O(1)
3. 实现
4. leetcode
    - 622设计循环队列
    - 641设计循环双端队列
    - 239滑动窗口最大值（双端单调队列）

### 2.4 优先级队列priority queue

1. 定义：元素出队时不再按照先进先出，而是按照优先级出队
2. 操作
    - 入队：O(logn)
    - 出队：O(logn)
3. 实现
    - python中使用二叉堆heap实现，heap底层是一个数组，元素入队时和出队后要调整元素位置。
4. leetcode相关题目
    - 23合并K个有序链表（归并、优先级队列）
    - 剑指offer40最小的k个数
    - 347前K个高频元素
